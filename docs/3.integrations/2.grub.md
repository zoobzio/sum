---
title: grub Integration
description: Database, key-value, and object storage integration
author: zoobzio
published: 2026-01-26
updated: 2026-01-26
tags:
  - integration
  - database
  - grub
  - storage
---

# grub Integration

[grub](https://github.com/zoobzio/grub) provides type-safe data access for SQL databases, key-value stores, and object storage. Sum's data helpers wire grub stores to the service registry and data catalog.

## What grub Provides

- `Database[M]` — SQL database operations with typed models
- `Store[M]` — Key-value store operations
- `Bucket[M]` — Object storage operations
- `Atomic` — Transaction/operation boundary abstraction

## The Integration

Sum provides three helper functions that:

1. Create a grub store
2. Pass it to your factory to create a domain interface
3. Register the interface with the service registry
4. Register the atomic with the data catalog

| Sum Helper | grub Type | Catalog Prefix |
|------------|-----------|----------------|
| `Database` | `grub.Database[M]` | `db://` |
| `Store` | `grub.Store[M]` | `kv://` |
| `Bucket` | `grub.Bucket[M]` | `bcs://` |

## Database Integration

For SQL databases:

```go
import (
    "github.com/jmoiron/sqlx"
    "github.com/zoobzio/astql"
    "github.com/zoobzio/grub"
    "github.com/zoobzio/sum"
)

type User struct {
    ID    string `db:"id"`
    Email string `db:"email"`
}

err := sum.Database[UserRepository, User](
    k,
    db,           // *sqlx.DB
    "users",      // table name
    "id",         // key column
    renderer,     // astql.Renderer for your dialect
    func(gdb *grub.Database[User]) UserRepository {
        return &userRepoImpl{db: gdb}
    },
)
```

The `astql.Renderer` handles SQL dialect differences (Postgres, MySQL, etc.).

## Store Integration

For key-value stores:

```go
err := sum.Store[SessionStore, Session](
    k,
    provider,     // grub.StoreProvider
    "sessions",   // store name
    func(s *grub.Store[Session]) SessionStore {
        return &sessionStoreImpl{store: s}
    },
)
```

The `StoreProvider` abstracts the underlying KV system (Redis, etcd, etc.).

## Bucket Integration

For object storage:

```go
err := sum.Bucket[DocumentStore, Document](
    k,
    provider,     // grub.BucketProvider
    "documents",  // bucket name
    func(b *grub.Bucket[Document]) DocumentStore {
        return &documentStoreImpl{bucket: b}
    },
)
```

The `BucketProvider` abstracts the storage backend (S3, GCS, filesystem).

## Atomic Operations

Each grub store exposes an `Atomic` for the data catalog:

```go
gdb, _ := grub.NewDatabase[User](db, "users", "id", renderer)

// The atomic tracks operations for observability
atomic := gdb.Atomic()
```

Sum registers these automatically. Access them via the catalog:

```go
catalog := svc.Catalog()
```

## Direct grub Usage

For advanced cases, use grub directly and register manually:

```go
// Create store directly
gdb, err := grub.NewDatabase[User](db, "users", "id", renderer)
if err != nil {
    return err
}

// Manual registration
sum.Register[UserRepository](k, &userRepoImpl{db: gdb})

// Manual catalog registration
svc.Catalog().RegisterDatabase("db://users", gdb.Atomic())
```

This is equivalent to what `sum.Database` does internally.

## Next Steps

- [fig Integration](3.fig.md) — Configuration loading
- [Data Stores Guide](../2.guides/5.data-stores.md) — Usage patterns
- [grub Documentation](https://pkg.go.dev/github.com/zoobzio/grub)
