---
title: Troubleshooting
description: Common issues and their solutions when using sum
author: zoobzio
published: 2026-01-26
updated: 2026-01-26
tags:
  - troubleshooting
  - debugging
  - errors
---

# Troubleshooting

Common issues and their solutions.

## Panics

### "sum: service not initialized, call New() first"

**Cause:** You called a function that requires the Service singleton before creating it.

**Solution:** Call `sum.New()` before using data helpers:

```go
// Wrong
sum.Database[UserRepo, User](k, db, ...) // panics

// Correct
svc := sum.New(sum.ServiceConfig{...})
sum.Database[UserRepo, User](k, db, ...)
```

### "slush: Start() called more than once"

**Cause:** `sum.Start()` was called multiple times.

**Solution:** Call `Start()` exactly once, typically at application startup:

```go
// Wrong
func getKey() sum.Key {
    return sum.Start() // called multiple times
}

// Correct
var key = sum.Start() // package-level, called once
```

### "slush: invalid key"

**Cause:** The key passed to `Register()`, `Freeze()`, or `Services()` is invalid—either zero-value or from a different registry.

**Solution:** Use the key returned by `Start()`:

```go
k := sum.Start()
sum.Register[MyService](k, impl) // use k, not a zero Key
```

### "slush: registry is frozen"

**Cause:** You called `Register()` after `Freeze()`.

**Solution:** Complete all registration before freezing:

```go
k := sum.Start()
sum.Register[ServiceA](k, implA)
sum.Register[ServiceB](k, implB)
sum.Freeze(k)
// No more Register() calls after this point
```

## Errors

### ErrNotFound

**Cause:** `Use[T]()` was called for a type that was never registered.

**Solution:** Ensure the type is registered before use:

```go
// Check registration
_, err := sum.Use[MyService](ctx)
if errors.Is(err, sum.ErrNotFound) {
    // MyService was never registered
}

// Or use MustUse if you want to panic on missing
svc := sum.MustUse[MyService](ctx) // panics if not found
```

**Common causes:**
- Typo in type name
- Registration in a different package that hasn't been initialized
- Test didn't call the setup code

### ErrAccessDenied

**Cause:** A guard denied access.

**Solution:** Check that the context contains the required credentials:

```go
// If your guard checks for a role
sum.Register[AdminService](k, impl).Guard(requireRole("admin"))

// The context must have the role
ctx := contextWithRole(ctx, "admin")
svc, err := sum.Use[AdminService](ctx) // now succeeds
```

### ErrInvalidKey

**Cause:** `Services()` was called with an invalid key.

**Solution:** Use the key from `Start()`:

```go
k := sum.Start()
// ...
services, err := sum.Services(k)
```

## Configuration Issues

### Config fails to load

**Cause:** Environment variables missing or malformed.

**Solution:** Check that required variables are set:

```go
type Config struct {
    DatabaseURL string `env:"DATABASE_URL,required"`
}

// Ensure DATABASE_URL is set before calling
err := sum.Config[Config](ctx, k, nil)
if err != nil {
    // Check error message for which field failed
    log.Fatalf("config error: %v", err)
}
```

### Secrets not loading

**Cause:** Secret provider not passed or misconfigured.

**Solution:** Pass a secret provider to `Config`:

```go
// With a secret provider
err := sum.Config[Config](ctx, k, mySecretProvider)

// Without secrets (pass nil)
err := sum.Config[Config](ctx, k, nil)
```

## Event Issues

### Listener not receiving events

**Cause:** Listener registered after events were emitted, or listener was closed.

**Solution:** Register listeners before emitting:

```go
// Register listener first
listener := MyEvent.Listen(handler)

// Then emit
MyEvent.Emit(ctx, data)

// Don't close until done
// listener.Close()
```

### Events firing multiple times

**Cause:** Multiple listeners registered, or `Listen` called multiple times.

**Solution:** Track listeners and close when done:

```go
// Store the listener
listener := MyEvent.Listen(handler)

// Close when no longer needed
listener.Close()

// For one-time handling, use ListenOnce
MyEvent.ListenOnce(handler) // auto-closes after first event
```

## Data Store Issues

### Database registration fails

**Cause:** Invalid database connection, table name, or key column.

**Solution:** Verify database connectivity before registration:

```go
// Test the connection first
if err := db.Ping(); err != nil {
    log.Fatalf("database not reachable: %v", err)
}

// Then register
err := sum.Database[Repo, Model](k, db, "table", "id", renderer, factory)
```

### "service not started" on Shutdown

**Cause:** `Shutdown()` called before `Start()`.

**Solution:** Only shutdown after starting:

```go
svc := sum.New(cfg)

// Wrong
svc.Shutdown(ctx) // error: service not started

// Correct
go svc.Start()
// ... later ...
svc.Shutdown(ctx)
```

## Test Issues

### Tests polluting each other

**Cause:** Registry state from one test affecting another.

**Solution:** Call `sum.Reset()` at the start of each test:

```go
func TestA(t *testing.T) {
    sum.Reset() // clean slate
    k := sum.Start()
    // ...
}

func TestB(t *testing.T) {
    sum.Reset() // clean slate again
    k := sum.Start()
    // ...
}
```

### "Reset not defined"

**Cause:** Missing build tag.

**Solution:** Run with the testing tag:

```bash
go test -tags testing ./...
```

## Next Steps

- [Testing Guide](1.testing.md) — Testing patterns
- [API Reference](../4.reference/1.api.md) — Function documentation
