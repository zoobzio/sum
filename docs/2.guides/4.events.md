---
title: Events
description: Typed event emission and handling with severity levels
author: zoobzio
published: 2026-01-26
updated: 2026-01-26
tags:
  - events
  - signals
  - pub-sub
---

# Events

Events provide typed, bidirectional signaling across your application. Define an event once, emit it from publishers, listen from subscribers—all with full type safety.

## Defining Events

An event combines a signal name with a typed payload:

```go
import (
    "github.com/zoobzio/capitan"
    "github.com/zoobzio/sum"
)

// Define the payload type
type OrderPlaced struct {
    OrderID    string
    CustomerID string
    Total      float64
}

// Create the event
var OrderPlacedEvent = sum.NewInfoEvent[OrderPlaced](
    capitan.Signal("order.placed"),
)
```

The type parameter `OrderPlaced` ensures all emitters and listeners agree on the payload shape.

## Severity Levels

Events emit at different severity levels, integrating with structured logging:

```go
// Debug level (development, verbose)
var DebugEvent = sum.NewDebugEvent[Payload](signal)

// Info level (normal operations)
var InfoEvent = sum.NewInfoEvent[Payload](signal)

// Warn level (potential issues)
var WarnEvent = sum.NewWarnEvent[Payload](signal)

// Error level (failures)
var ErrorEvent = sum.NewErrorEvent[Payload](signal)

// Custom level
var CustomEvent = sum.NewEvent[Payload](signal, capitan.SeverityInfo)
```

Choose the level that matches the event's significance.

## Emitting Events

Emit an event with a payload:

```go
func PlaceOrder(ctx context.Context, order Order) error {
    // ... process order ...

    // Emit the event
    OrderPlacedEvent.Emit(ctx, OrderPlaced{
        OrderID:    order.ID,
        CustomerID: order.CustomerID,
        Total:      order.Total,
    })

    return nil
}
```

The context carries tracing and logging information through the event system.

## Listening for Events

Register a listener to handle events:

```go
func init() {
    OrderPlacedEvent.Listen(func(ctx context.Context, e OrderPlaced) {
        log.Printf("Order %s placed for customer %s", e.OrderID, e.CustomerID)
    })
}
```

Listeners receive the typed payload directly—no casting required.

### Managing Listeners

`Listen()` returns a `*capitan.Listener` for lifecycle management:

```go
listener := OrderPlacedEvent.Listen(handler)

// Later, stop listening
listener.Close()
```

Always close listeners when they're no longer needed to prevent memory leaks.

### One-Time Listeners

For events you only need to handle once:

```go
// Automatically closes after first event
OrderPlacedEvent.ListenOnce(func(ctx context.Context, e OrderPlaced) {
    log.Printf("First order placed: %s", e.OrderID)
})
```

The listener automatically unregisters after firing once.

## Event Patterns

### Domain Events

Use events for domain-significant occurrences:

```go
var (
    UserCreated   = sum.NewInfoEvent[User](capitan.Signal("user.created"))
    UserDeleted   = sum.NewWarnEvent[UserID](capitan.Signal("user.deleted"))
    PaymentFailed = sum.NewErrorEvent[PaymentError](capitan.Signal("payment.failed"))
)
```

### System Events

Use events for infrastructure concerns:

```go
var (
    CacheHit    = sum.NewDebugEvent[CacheKey](capitan.Signal("cache.hit"))
    CacheMiss   = sum.NewDebugEvent[CacheKey](capitan.Signal("cache.miss"))
    DBQuerySlow = sum.NewWarnEvent[SlowQuery](capitan.Signal("db.query.slow"))
)
```

### Request Lifecycle

Track request processing:

```go
var (
    RequestStarted  = sum.NewDebugEvent[RequestInfo](capitan.Signal("request.started"))
    RequestComplete = sum.NewInfoEvent[RequestResult](capitan.Signal("request.complete"))
    RequestFailed   = sum.NewErrorEvent[RequestError](capitan.Signal("request.failed"))
)
```

## Integration with Logging

Events integrate with capitan's structured logging. Configure capitan to route events to your logging infrastructure:

```go
// Events at Info level and above will be logged
capitan.Info(ctx, signal, fields...)  // logged
capitan.Debug(ctx, signal, fields...) // may be filtered
```

## Best Practices

1. **Define events as package variables** — Makes them discoverable and testable
2. **Use meaningful signal names** — `user.created` not `uc` or `event1`
3. **Choose appropriate severity** — Debug for verbose, Error for failures
4. **Close listeners** — Prevent memory leaks in long-running applications
5. **Keep payloads focused** — Include only what listeners need

## Testing Events

See the [Testing Guide](1.testing.md#testing-events) for patterns on testing event emission and handling.

## Next Steps

- [Data Stores Guide](5.data-stores.md) — Database and storage helpers
- [API Reference](../4.reference/1.api.md) — Complete function documentation
