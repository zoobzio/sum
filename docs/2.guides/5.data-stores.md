---
title: Data Stores
description: Database, key-value, and object storage helpers
author: zoobzio
published: 2026-01-26
updated: 2026-01-26
tags:
  - database
  - storage
  - grub
---

# Data Stores

Sum provides helpers that wire data stores to both the service registry and the data catalog. One call creates the store, wraps it in your repository, registers it as a service, and catalogs it for observability.

## The Pattern

All data helpers follow the same pattern:

1. Create the underlying store (grub.Database, grub.Store, or grub.Bucket)
2. Pass it to your factory function to create a domain interface
3. Register the interface with the service registry
4. Register the store's atomic with the data catalog

```go
sum.Database[RepoInterface, Model](key, connection, name, keyCol, renderer, factory)
```

The type parameters:
- `RepoInterface` — Your domain interface (what you'll retrieve via `Use`)
- `Model` — The data model type (what grub operates on)

## Database (SQL)

For SQL databases via `grub.Database`:

```go
type User struct {
    ID    string `db:"id"`
    Email string `db:"email"`
    Name  string `db:"name"`
}

type UserRepository interface {
    Find(ctx context.Context, id string) (*User, error)
    Save(ctx context.Context, user *User) error
    Delete(ctx context.Context, id string) error
}

type userRepoImpl struct {
    db *grub.Database[User]
}

func (r *userRepoImpl) Find(ctx context.Context, id string) (*User, error) {
    return r.db.Get(ctx, id)
}

// ... other methods ...

// Wire it all together
err := sum.Database[UserRepository, User](
    k,                  // registration key
    sqlxDB,             // *sqlx.DB connection
    "users",            // table name
    "id",               // primary key column
    astqlRenderer,      // SQL renderer
    func(gdb *grub.Database[User]) UserRepository {
        return &userRepoImpl{db: gdb}
    },
)
```

The database is now:
- Retrievable via `sum.Use[UserRepository](ctx)`
- Registered in the data catalog as `db://users`

## Store (Key-Value)

For key-value stores via `grub.Store`:

```go
type Session struct {
    UserID    string
    Token     string
    ExpiresAt time.Time
}

type SessionStore interface {
    Get(ctx context.Context, token string) (*Session, error)
    Set(ctx context.Context, session *Session) error
    Delete(ctx context.Context, token string) error
}

type sessionStoreImpl struct {
    store *grub.Store[Session]
}

// ... methods ...

err := sum.Store[SessionStore, Session](
    k,                  // registration key
    kvProvider,         // grub.StoreProvider (Redis, etc.)
    "sessions",         // store name
    func(s *grub.Store[Session]) SessionStore {
        return &sessionStoreImpl{store: s}
    },
)
```

Registered in the data catalog as `kv://sessions`.

## Bucket (Object Storage)

For object storage via `grub.Bucket`:

```go
type Document struct {
    ID          string
    ContentType string
    Data        []byte
}

type DocumentStore interface {
    Get(ctx context.Context, id string) (*Document, error)
    Put(ctx context.Context, doc *Document) error
    Delete(ctx context.Context, id string) error
}

type documentStoreImpl struct {
    bucket *grub.Bucket[Document]
}

// ... methods ...

err := sum.Bucket[DocumentStore, Document](
    k,                  // registration key
    bucketProvider,     // grub.BucketProvider (S3, GCS, etc.)
    "documents",        // bucket name
    func(b *grub.Bucket[Document]) DocumentStore {
        return &documentStoreImpl{bucket: b}
    },
)
```

Registered in the data catalog as `bcs://documents`.

## The Factory Function

The factory function bridges grub's generic store to your domain interface:

```go
func(gdb *grub.Database[User]) UserRepository {
    return &userRepoImpl{db: gdb}
}
```

This pattern:
- Lets you define domain-specific methods
- Hides grub internals from consumers
- Allows adding caching, validation, or logging

## Data Catalog

All registered stores appear in the scio data catalog:

```go
svc := sum.New(cfg)
catalog := svc.Catalog()

// List all registered stores
// db://users, kv://sessions, bcs://documents
```

The catalog enables:
- Health checks across all stores
- Metrics collection
- Service discovery

## Error Handling

Data helpers return errors from store creation:

```go
err := sum.Database[Repo, Model](k, db, table, col, renderer, factory)
if err != nil {
    // grub.NewDatabase failed—check connection, table, column
    log.Fatalf("failed to register database: %v", err)
}
```

Common errors:
- Invalid database connection
- Table doesn't exist
- Key column doesn't exist
- Provider configuration issues

## Best Practices

1. **Define clear interfaces** — Your repository interface should reflect domain operations, not storage details
2. **Handle errors in the factory** — Validate assumptions about the store
3. **Use meaningful names** — Table/store/bucket names appear in the catalog
4. **Register all stores at startup** — Before freezing the registry

## Next Steps

- [Service Registry Guide](3.service-registry.md) — Registration and guards
- [API Reference](../4.reference/1.api.md) — Complete function documentation
