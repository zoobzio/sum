---
title: Data Stores
description: Database, key-value, and object storage helpers
author: zoobzio
published: 2026-01-26
updated: 2026-01-26
tags:
  - database
  - storage
  - grub
---

# Data Stores

Sum provides wrapper types for grub data stores that automatically register with the scio data catalog.

## The Pattern

All data helpers follow the same pattern:

1. Create a sum wrapper type (Database, Store, or Bucket)
2. The wrapper embeds the underlying grub type
3. The store's atomic is registered with the data catalog
4. Embed the wrapper in your own struct to add custom methods

```go
db, err := sum.NewDatabase[Model](connection, table, renderer)
```

The type parameter:
- `Model` — The data model type (what grub operates on)

## Database (SQL)

For SQL databases via `grub.Database`:

```go
type User struct {
    ID    string `db:"id"`
    Email string `db:"email"`
    Name  string `db:"name"`
}

// Embed sum.Database to add custom methods
type UserRepository struct {
    *sum.Database[User]
}

func (r *UserRepository) FindByEmail(ctx context.Context, email string) (*User, error) {
    // Custom query using embedded grub.Database methods
    return r.Database.QueryOne(ctx, /* query */)
}

// Create and register
database, err := sum.NewDatabase[User](
    sqlxDB,             // *sqlx.DB connection
    "users",            // table name
    astqlRenderer,      // SQL renderer
)
if err != nil {
    return err
}

userRepo := &UserRepository{Database: database}
```

The database is now:
- Available via the `userRepo` variable
- Registered in the data catalog as `db://users`

## Store (Key-Value)

For key-value stores via `grub.Store`:

```go
type Session struct {
    UserID    string
    Token     string
    ExpiresAt time.Time
}

// Embed sum.Store to add custom methods
type SessionStore struct {
    *sum.Store[Session]
}

func (s *SessionStore) GetByToken(ctx context.Context, token string) (*Session, error) {
    return s.Store.Get(ctx, token)
}

// Create and register
store, err := sum.NewStore[Session](
    kvProvider,         // grub.StoreProvider (Redis, etc.)
    "sessions",         // store name
)
if err != nil {
    return err
}

sessionStore := &SessionStore{Store: store}
```

Registered in the data catalog as `kv://sessions`.

## Bucket (Object Storage)

For object storage via `grub.Bucket`:

```go
type Document struct {
    ID          string
    ContentType string
    Data        []byte
}

// Embed sum.Bucket to add custom methods
type DocumentStore struct {
    *sum.Bucket[Document]
}

func (d *DocumentStore) GetDocument(ctx context.Context, id string) (*Document, error) {
    return d.Bucket.Get(ctx, id)
}

// Create and register
bucket, err := sum.NewBucket[Document](
    bucketProvider,     // grub.BucketProvider (S3, GCS, etc.)
    "documents",        // bucket name
)
if err != nil {
    return err
}

docStore := &DocumentStore{Bucket: bucket}
```

Registered in the data catalog as `bcs://documents`.

## The Embedding Pattern

Embedding the sum wrapper types in your own structs lets you:
- Add domain-specific methods
- Access the underlying grub type for advanced operations
- Keep a clean API while leveraging grub's functionality

```go
type UserRepository struct {
    *sum.Database[User]
}

func (r *UserRepository) FindActive(ctx context.Context) ([]*User, error) {
    // Custom method using embedded Database
    return r.Database.Query(ctx, /* custom query */)
}
```

## Data Catalog

All registered stores appear in the scio data catalog:

```go
svc := sum.New(cfg)
catalog := svc.Catalog()

// List all registered stores
// db://users, kv://sessions, bcs://documents
```

The catalog enables:
- Health checks across all stores
- Metrics collection
- Service discovery

## Error Handling

All data helpers return errors from store creation or catalog registration:

```go
database, err := sum.NewDatabase[Model](db, table, renderer)
if err != nil {
    log.Fatalf("failed to create database: %v", err)
}

store, err := sum.NewStore[Model](provider, "name")
if err != nil {
    log.Fatalf("failed to create store: %v", err)
}

bucket, err := sum.NewBucket[Model](provider, "name")
if err != nil {
    log.Fatalf("failed to create bucket: %v", err)
}
```

Common errors:
- Invalid database connection
- Table doesn't exist
- Catalog registration failure (e.g., duplicate name)

## Best Practices

1. **Define clear interfaces** — Your repository interface should reflect domain operations, not storage details
2. **Handle errors in the factory** — Validate assumptions about the store
3. **Use meaningful names** — Table/store/bucket names appear in the catalog
4. **Register all stores at startup** — Before freezing the registry

## Next Steps

- [Service Registry Guide](3.service-registry.md) — Registration and guards
- [API Reference](../4.reference/1.api.md) — Complete function documentation
