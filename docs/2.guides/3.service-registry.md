---
title: Service Registry
description: Type-safe service registration, retrieval, and guards
author: zoobzio
published: 2026-01-26
updated: 2026-01-26
tags:
  - service-registry
  - dependency-injection
  - guards
---

# Service Registry

The service registry is a type-safe service locator. Register implementations against contract types, retrieve them anywhere by type.

## Registration Lifecycle

The registry has three phases:

1. **Initialize** — Call `Start()` to get a registration key
2. **Register** — Use the key to register implementations
3. **Freeze** — Lock the registry to prevent further changes

```go
// 1. Initialize
k := sum.Start()

// 2. Register
sum.Register[UserRepository](k, &pgUserRepo{db})
sum.Register[EmailService](k, &smtpService{cfg})
sum.Register[CacheService](k, &redisCache{client})

// 3. Freeze
sum.Freeze(k)
```

After freezing, `Register()` panics. This catches late registration bugs at startup rather than runtime.

## Contract Types

Register against interfaces, not concrete types:

```go
// Good: register against the interface
type UserRepository interface {
    Find(ctx context.Context, id string) (*User, error)
    Save(ctx context.Context, user *User) error
}

sum.Register[UserRepository](k, &pgUserRepo{})

// Bad: registering the concrete type
sum.Register[*pgUserRepo](k, &pgUserRepo{}) // works but defeats the purpose
```

Using interfaces allows swapping implementations without changing call sites.

## Retrieval

Retrieve services by their contract type:

```go
// With error handling
repo, err := sum.Use[UserRepository](ctx)
if err != nil {
    // ErrNotFound or ErrAccessDenied
}

// Panic on failure (for required services)
repo := sum.MustUse[UserRepository](ctx)
```

Use `Use()` when the service might not exist or access might be denied. Use `MustUse()` for services that must exist.

## Guards

Guards are functions that run on every `Use()` call. They can permit or deny access based on context.

```go
type Guard func(ctx context.Context) error
```

Attach guards during registration:

```go
sum.Register[AdminService](k, &adminImpl{}).
    Guard(requireRole("admin")).
    Guard(requireTenant)
```

Guards run in order. If any guard returns an error, `Use()` returns `ErrAccessDenied`.

### Common Guard Patterns

**Role-based access:**

```go
func requireRole(role string) sum.Guard {
    return func(ctx context.Context) error {
        if !hasRole(ctx, role) {
            return fmt.Errorf("requires role: %s", role)
        }
        return nil
    }
}
```

**Tenant isolation:**

```go
func requireTenant(ctx context.Context) error {
    if getTenantID(ctx) == "" {
        return errors.New("tenant required")
    }
    return nil
}
```

**Feature flags:**

```go
func requireFeature(flag string) sum.Guard {
    return func(ctx context.Context) error {
        if !isFeatureEnabled(ctx, flag) {
            return fmt.Errorf("feature not enabled: %s", flag)
        }
        return nil
    }
}
```

## Service Enumeration

List all registered services (requires the key):

```go
services, err := sum.Services(k)
if err != nil {
    // ErrInvalidKey
}

for _, svc := range services {
    fmt.Printf("Service: %s -> %s\n", svc.Interface, svc.Impl)
}
```

This is useful for debugging and health checks.

## Signals

The registry emits signals on key events:

| Signal | When | Fields |
|--------|------|--------|
| `SignalRegistered` | Service registered | `KeyInterface`, `KeyImpl` |
| `SignalAccessed` | Service retrieved | `KeyInterface` |
| `SignalDenied` | Guard denied access | `KeyInterface`, `KeyError` |
| `SignalNotFound` | Service not found | `KeyInterface` |

Listen for these to add observability:

```go
capitan.Hook(sum.SignalAccessed, func(ctx context.Context, ev *capitan.Event) {
    iface, _ := sum.KeyInterface.From(ev)
    log.Printf("Service accessed: %s", iface)
})
```

## Best Practices

1. **Register early** — Complete registration at startup, before handling requests
2. **Freeze explicitly** — Don't rely on implicit freezing
3. **Use interfaces** — Register against contracts, not implementations
4. **Guard consistently** — Apply guards at registration, not at call sites
5. **Fail fast** — Use `MustUse()` for required services to catch misconfiguration early

## Next Steps

- [Events Guide](4.events.md) — Typed event system
- [Data Stores Guide](5.data-stores.md) — Database and storage helpers
- [API Reference](../4.reference/1.api.md) — Complete function documentation
