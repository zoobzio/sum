---
title: API Reference
description: Complete function documentation for sum
author: zoobzio
published: 2026-01-26
updated: 2026-01-26
tags:
  - reference
  - api
  - functions
---

# API Reference

Complete documentation for all public functions in sum.

## Service

### New

```go
func New(cfg ServiceConfig) *Service
```

Creates or returns the singleton Service.

**Parameters:**
- `cfg` — Service configuration (host, port)

**Returns:** The singleton `*Service` instance.

**Behavior:**
- First call creates the instance with the provided config
- Subsequent calls return the existing instance, ignoring the config
- Thread-safe via `sync.Once`

**Example:**

```go
svc := sum.New(sum.ServiceConfig{Host: "localhost", Port: 8080})
```

---

## Registry

### Start

```go
func Start() Key
```

Initializes the service registry and returns a registration key.

**Returns:** A `Key` for use with `Register`, `Freeze`, and `Services`.

**Panics:** If called more than once.

**Example:**

```go
k := sum.Start()
```

---

### Register

```go
func Register[T any](k Key, impl T) *Handle[T]
```

Registers a service implementation for the contract type `T`.

**Type Parameters:**
- `T` — The contract type (typically an interface)

**Parameters:**
- `k` — The registration key from `Start()`
- `impl` — The implementation to register

**Returns:** A `*Handle[T]` for attaching guards.

**Panics:**
- If `Start()` has not been called
- If the key is invalid
- If the registry is frozen

**Example:**

```go
sum.Register[UserRepository](k, &pgUserRepo{db})
```

---

### Freeze

```go
func Freeze(k Key)
```

Prevents further service registration.

**Parameters:**
- `k` — The registration key from `Start()`

**Panics:** If the key is invalid.

**Example:**

```go
sum.Freeze(k)
```

---

### Use

```go
func Use[T any](ctx context.Context) (T, error)
```

Retrieves a service by its contract type.

**Type Parameters:**
- `T` — The contract type to retrieve

**Parameters:**
- `ctx` — Context passed to guards

**Returns:**
- The registered implementation of type `T`
- Error if not found or access denied

**Errors:**
- `ErrNotFound` — No service registered for type `T`
- `ErrAccessDenied` — A guard denied access

**Example:**

```go
repo, err := sum.Use[UserRepository](ctx)
if err != nil {
    return err
}
```

---

### MustUse

```go
func MustUse[T any](ctx context.Context) T
```

Retrieves a service by its contract type, panicking on failure.

**Type Parameters:**
- `T` — The contract type to retrieve

**Parameters:**
- `ctx` — Context passed to guards

**Returns:** The registered implementation of type `T`.

**Panics:** If the service is not registered or a guard denies access.

**Example:**

```go
repo := sum.MustUse[UserRepository](ctx)
```

---

### Services

```go
func Services(k Key) ([]ServiceInfo, error)
```

Returns information about all registered services.

**Parameters:**
- `k` — The registration key from `Start()`

**Returns:**
- Slice of `ServiceInfo` describing each registered service
- Error if the key is invalid

**Errors:**
- `ErrInvalidKey` — The key is invalid

**Example:**

```go
services, err := sum.Services(k)
for _, svc := range services {
    fmt.Printf("%s -> %s\n", svc.Interface, svc.Impl)
}
```

---

## Configuration

### Config

```go
func Config[T any](ctx context.Context, k Key, provider fig.SecretProvider) error
```

Loads configuration and registers it as a service.

**Type Parameters:**
- `T` — The configuration struct type

**Parameters:**
- `ctx` — Context for loading
- `k` — The registration key from `Start()`
- `provider` — Secret provider (pass `nil` if not needed)

**Returns:** Error if loading fails.

**Behavior:**
1. Loads configuration into a new `T` via fig
2. Registers it with the service registry
3. Retrievable later via `Use[T](ctx)`

**Example:**

```go
err := sum.Config[AppConfig](ctx, k, nil)
cfg := sum.MustUse[AppConfig](ctx)
```

---

## Data

### Database

```go
func Database[C, M any](k Key, db *sqlx.DB, table, keyCol string, renderer astql.Renderer, factory func(*grub.Database[M]) C) error
```

Creates a database store, wraps it, and registers with the service registry and data catalog.

**Type Parameters:**
- `C` — The contract type (repository interface)
- `M` — The model type

**Parameters:**
- `k` — The registration key from `Start()`
- `db` — The sqlx database connection
- `table` — The table name
- `keyCol` — The primary key column name
- `renderer` — SQL renderer for the database dialect
- `factory` — Function that wraps the grub database in your interface

**Returns:** Error if store creation fails.

**Behavior:**
1. Creates `grub.Database[M]`
2. Passes it to factory to get `C`
3. Registers `C` with the service registry
4. Registers the atomic with scio as `db://table`

**Example:**

```go
err := sum.Database[UserRepo, User](k, db, "users", "id", renderer,
    func(gdb *grub.Database[User]) UserRepo {
        return &userRepoImpl{db: gdb}
    },
)
```

See also: [Types Reference](2.types.md#grub-types)

---

### Store

```go
func Store[C, M any](k Key, provider grub.StoreProvider, name string, factory func(*grub.Store[M]) C) error
```

Creates a key-value store, wraps it, and registers with the service registry and data catalog.

**Type Parameters:**
- `C` — The contract type (store interface)
- `M` — The model type

**Parameters:**
- `k` — The registration key from `Start()`
- `provider` — The KV store provider
- `name` — The store name
- `factory` — Function that wraps the grub store in your interface

**Returns:** Error if store creation fails.

**Behavior:**
1. Creates `grub.Store[M]`
2. Passes it to factory to get `C`
3. Registers `C` with the service registry
4. Registers the atomic with scio as `kv://name`

**Example:**

```go
err := sum.Store[SessionStore, Session](k, provider, "sessions",
    func(s *grub.Store[Session]) SessionStore {
        return &sessionStoreImpl{store: s}
    },
)
```

---

### Bucket

```go
func Bucket[C, M any](k Key, provider grub.BucketProvider, name string, factory func(*grub.Bucket[M]) C) error
```

Creates an object storage bucket, wraps it, and registers with the service registry and data catalog.

**Type Parameters:**
- `C` — The contract type (bucket interface)
- `M` — The model type

**Parameters:**
- `k` — The registration key from `Start()`
- `provider` — The bucket provider
- `name` — The bucket name
- `factory` — Function that wraps the grub bucket in your interface

**Returns:** Error if store creation fails.

**Behavior:**
1. Creates `grub.Bucket[M]`
2. Passes it to factory to get `C`
3. Registers `C` with the service registry
4. Registers the atomic with scio as `bcs://name`

**Example:**

```go
err := sum.Bucket[DocumentStore, Document](k, provider, "documents",
    func(b *grub.Bucket[Document]) DocumentStore {
        return &documentStoreImpl{bucket: b}
    },
)
```

---

## Events

### NewEvent

```go
func NewEvent[T any](signal capitan.Signal, level capitan.Severity) Event[T]
```

Creates an Event with the given signal and severity level.

**Type Parameters:**
- `T` — The event payload type

**Parameters:**
- `signal` — The capitan signal name
- `level` — The severity level

**Returns:** An `Event[T]` for emitting and listening.

**Example:**

```go
var MyEvent = sum.NewEvent[Payload](capitan.Signal("my.event"), capitan.SeverityInfo)
```

---

### NewDebugEvent

```go
func NewDebugEvent[T any](signal capitan.Signal) Event[T]
```

Creates an Event that emits at Debug level.

---

### NewInfoEvent

```go
func NewInfoEvent[T any](signal capitan.Signal) Event[T]
```

Creates an Event that emits at Info level.

---

### NewWarnEvent

```go
func NewWarnEvent[T any](signal capitan.Signal) Event[T]
```

Creates an Event that emits at Warn level.

---

### NewErrorEvent

```go
func NewErrorEvent[T any](signal capitan.Signal) Event[T]
```

Creates an Event that emits at Error level.

---

## Next Steps

- [Types Reference](2.types.md) — Type definitions
- [Concepts](../1.learn/3.concepts.md) — Mental models
