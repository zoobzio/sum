---
title: API Reference
description: Complete function documentation for sum
author: zoobzio
published: 2026-01-26
updated: 2026-01-26
tags:
  - reference
  - api
  - functions
---

# API Reference

Complete documentation for all public functions in sum.

## Service

### New

```go
func New(cfg ServiceConfig) *Service
```

Creates or returns the singleton Service.

**Parameters:**
- `cfg` — Service configuration (host, port)

**Returns:** The singleton `*Service` instance.

**Behavior:**
- First call creates the instance with the provided config
- Subsequent calls return the existing instance, ignoring the config
- Thread-safe via `sync.Once`

**Example:**

```go
svc := sum.New(sum.ServiceConfig{Host: "localhost", Port: 8080})
```

---

## Registry

### Start

```go
func Start() Key
```

Initializes the service registry and returns a registration key.

**Returns:** A `Key` for use with `Register`, `Freeze`, and `Services`.

**Panics:** If called more than once.

**Example:**

```go
k := sum.Start()
```

---

### Register

```go
func Register[T any](k Key, impl T) *Handle[T]
```

Registers a service implementation for the contract type `T`.

**Type Parameters:**
- `T` — The contract type (typically an interface)

**Parameters:**
- `k` — The registration key from `Start()`
- `impl` — The implementation to register

**Returns:** A `*Handle[T]` for attaching guards.

**Panics:**
- If `Start()` has not been called
- If the key is invalid
- If the registry is frozen

**Example:**

```go
sum.Register[UserRepository](k, &pgUserRepo{db})
```

---

### Freeze

```go
func Freeze(k Key)
```

Prevents further service registration.

**Parameters:**
- `k` — The registration key from `Start()`

**Panics:** If the key is invalid.

**Example:**

```go
sum.Freeze(k)
```

---

### Use

```go
func Use[T any](ctx context.Context) (T, error)
```

Retrieves a service by its contract type.

**Type Parameters:**
- `T` — The contract type to retrieve

**Parameters:**
- `ctx` — Context passed to guards

**Returns:**
- The registered implementation of type `T`
- Error if not found or access denied

**Errors:**
- `ErrNotFound` — No service registered for type `T`
- `ErrAccessDenied` — A guard denied access

**Example:**

```go
repo, err := sum.Use[UserRepository](ctx)
if err != nil {
    return err
}
```

---

### MustUse

```go
func MustUse[T any](ctx context.Context) T
```

Retrieves a service by its contract type, panicking on failure.

**Type Parameters:**
- `T` — The contract type to retrieve

**Parameters:**
- `ctx` — Context passed to guards

**Returns:** The registered implementation of type `T`.

**Panics:** If the service is not registered or a guard denies access.

**Example:**

```go
repo := sum.MustUse[UserRepository](ctx)
```

---

### Services

```go
func Services(k Key) ([]ServiceInfo, error)
```

Returns information about all registered services.

**Parameters:**
- `k` — The registration key from `Start()`

**Returns:**
- Slice of `ServiceInfo` describing each registered service
- Error if the key is invalid

**Errors:**
- `ErrInvalidKey` — The key is invalid

**Example:**

```go
services, err := sum.Services(k)
for _, svc := range services {
    fmt.Printf("%s -> %s\n", svc.Interface, svc.Impl)
}
```

---

## Configuration

### Config

```go
func Config[T any](ctx context.Context, k Key, provider fig.SecretProvider) error
```

Loads configuration and registers it as a service.

**Type Parameters:**
- `T` — The configuration struct type

**Parameters:**
- `ctx` — Context for loading
- `k` — The registration key from `Start()`
- `provider` — Secret provider (pass `nil` if not needed)

**Returns:** Error if loading fails.

**Behavior:**
1. Loads configuration into a new `T` via fig
2. Registers it with the service registry
3. Retrievable later via `Use[T](ctx)`

**Example:**

```go
err := sum.Config[AppConfig](ctx, k, nil)
cfg := sum.MustUse[AppConfig](ctx)
```

---

## Data

### NewDatabase

```go
func NewDatabase[M any](db *sqlx.DB, table string, renderer astql.Renderer) (*Database[M], error)
```

Creates a database wrapper and registers with the data catalog.

**Type Parameters:**
- `M` — The model type

**Parameters:**
- `db` — The sqlx database connection
- `table` — The table name
- `renderer` — SQL renderer for the database dialect

**Returns:**
- `*Database[M]` — Wrapper embedding `*grub.Database[M]`
- Error if store creation fails

**Behavior:**
1. Creates `grub.Database[M]`
2. Registers the atomic with scio as `db://table`
3. Returns wrapper for embedding in your own types

**Example:**

```go
database, err := sum.NewDatabase[User](db, "users", renderer)
if err != nil {
    return err
}

// Embed in your own type
type UserRepo struct {
    *sum.Database[User]
}
userRepo := &UserRepo{Database: database}
```

See also: [Types Reference](2.types.md#grub-types)

---

### NewStore

```go
func NewStore[M any](provider grub.StoreProvider, name string) (*Store[M], error)
```

Creates a key-value store wrapper and registers with the data catalog.

**Type Parameters:**
- `M` — The model type

**Parameters:**
- `provider` — The KV store provider
- `name` — The store name

**Returns:**
- `*Store[M]` — Wrapper embedding `*grub.Store[M]`
- Error if catalog registration fails

**Behavior:**
1. Creates `grub.Store[M]`
2. Registers the atomic with scio as `kv://name`
3. Returns wrapper for embedding in your own types

**Example:**

```go
store, err := sum.NewStore[Session](provider, "sessions")
if err != nil {
    return err
}

// Embed in your own type
type SessionStore struct {
    *sum.Store[Session]
}
sessionStore := &SessionStore{Store: store}
```

---

### NewBucket

```go
func NewBucket[M any](provider grub.BucketProvider, name string) (*Bucket[M], error)
```

Creates an object storage bucket wrapper and registers with the data catalog.

**Type Parameters:**
- `M` — The model type

**Parameters:**
- `provider` — The bucket provider
- `name` — The bucket name

**Returns:**
- `*Bucket[M]` — Wrapper embedding `*grub.Bucket[M]`
- Error if catalog registration fails

**Behavior:**
1. Creates `grub.Bucket[M]`
2. Registers the atomic with scio as `bcs://name`
3. Returns wrapper for embedding in your own types

**Example:**

```go
bucket, err := sum.NewBucket[Document](provider, "documents")
if err != nil {
    return err
}

// Embed in your own type
type DocumentStore struct {
    *sum.Bucket[Document]
}
docStore := &DocumentStore{Bucket: bucket}
```

---

## Events

### NewEvent

```go
func NewEvent[T any](signal capitan.Signal, level capitan.Severity) Event[T]
```

Creates an Event with the given signal and severity level.

**Type Parameters:**
- `T` — The event payload type

**Parameters:**
- `signal` — The capitan signal name
- `level` — The severity level

**Returns:** An `Event[T]` for emitting and listening.

**Example:**

```go
var MyEvent = sum.NewEvent[Payload](capitan.Signal("my.event"), capitan.SeverityInfo)
```

---

### NewDebugEvent

```go
func NewDebugEvent[T any](signal capitan.Signal) Event[T]
```

Creates an Event that emits at Debug level.

---

### NewInfoEvent

```go
func NewInfoEvent[T any](signal capitan.Signal) Event[T]
```

Creates an Event that emits at Info level.

---

### NewWarnEvent

```go
func NewWarnEvent[T any](signal capitan.Signal) Event[T]
```

Creates an Event that emits at Warn level.

---

### NewErrorEvent

```go
func NewErrorEvent[T any](signal capitan.Signal) Event[T]
```

Creates an Event that emits at Error level.

---

## Next Steps

- [Types Reference](2.types.md) — Type definitions
- [Concepts](../1.learn/3.concepts.md) — Mental models
