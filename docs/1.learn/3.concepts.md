---
title: Concepts
description: Core abstractions and mental models for working with sum
author: zoobzio
published: 2026-01-26
updated: 2026-01-26
tags:
  - concepts
  - mental-models
  - architecture
---

# Concepts

Sum has four core abstractions: the Service, the Registry, Events, and Data Helpers. Understanding these mental models makes the API intuitive.

## Service

The `Service` is a singleton that owns the application lifecycle.

**What it represents:** Your running application—the HTTP server, data catalog, and configuration bundled together.

**Why it exists:** Go applications need coordinated startup and shutdown. The Service provides a single point of control: `New()` creates it, `Run()` starts it and blocks until shutdown, `Shutdown()` stops it gracefully.

**How to think about it:** The Service is the root. Everything else—endpoints, data stores, configuration—attaches to it. There is exactly one per process.

```go
svc := sum.New(sum.ServiceConfig{Host: "localhost", Port: 8080})
svc.Handle(endpoints...)
svc.Run() // blocks until SIGINT/SIGTERM
```

See [Service](../4.reference/2.types.md#service) in the Types Reference.

## Registry

The Registry is a type-safe service locator.

**What it represents:** A map from contract types to implementations, with compile-time type safety.

**Why it exists:** Services need to find each other. String-based lookups are error-prone. Dependency injection frameworks are heavyweight. The Registry uses Go generics: register `*userRepoImpl` as `UserRepository`, retrieve it later by asking for `UserRepository`.

**How to think about it:** The Registry is a phone book indexed by type. Registration happens at startup, lookup happens at runtime. The `Key` controls write access; anyone can read.

```go
// Startup: populate the registry
k := sum.Start()
sum.Register[UserRepository](k, &userRepoImpl{})
sum.Freeze(k)

// Runtime: lookup by type
repo := sum.MustUse[UserRepository](ctx)
```

**Guards:** Registration returns a `Handle` for attaching guards—functions that run on every `Use()` call and can deny access based on context.

```go
sum.Register[AdminService](k, &adminImpl{}).
    Guard(requireRole("admin"))
```

See [Registry Functions](../4.reference/1.api.md#registry) in the API Reference.

## Events

Events provide typed, bidirectional signaling.

**What it represents:** A named signal with a typed payload. Emit from one place, listen from many.

**Why it exists:** Applications need to communicate across boundaries without tight coupling. The `Event[T]` wrapper provides type safety over the underlying capitan signal system.

**How to think about it:** An Event is a radio channel. `Emit()` broadcasts, `Listen()` tunes in. The type parameter `T` ensures emitters and listeners agree on the payload shape.

```go
var OrderPlaced = sum.NewInfoEvent[Order](capitan.Signal("order.placed"))

// Publisher
OrderPlaced.Emit(ctx, order)

// Subscriber
OrderPlaced.Listen(func(ctx context.Context, o Order) {
    // handle order
})
```

**Severity levels:** Events can emit at Debug, Info, Warn, or Error levels, integrating with structured logging.

See [Event](../4.reference/2.types.md#event) in the Types Reference.

## Data Wrappers

Data wrappers provide typed access to persistence with automatic catalog registration.

**What they represent:** Wrapper types that embed grub stores and register with the data catalog on creation.

**Why they exist:** The pattern is always the same: create store, register it with the catalog. The wrappers eliminate boilerplate and ensure consistency.

**How to think about it:** Data wrappers are thin layers over grub stores with automatic catalog registration. Embed them in your own types to add domain-specific methods.

```go
database, err := sum.NewDatabase[User](db, "users", renderer)

type UserRepo struct {
    *sum.Database[User]
}
userRepo := &UserRepo{Database: database}
```

Three variants exist:
- `Database` — SQL databases via grub.Database
- `Store` — Key-value stores via grub.Store
- `Bucket` — Object storage via grub.Bucket

See [Data Functions](../4.reference/1.api.md#data) in the API Reference.

## Next Steps

- [Architecture](4.architecture.md) — How these pieces fit together internally
- [API Reference](../4.reference/1.api.md) — Complete function documentation
