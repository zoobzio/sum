---
title: Architecture
description: Internal structure, data flow, and design decisions in sum
author: zoobzio
published: 2026-01-26
updated: 2026-01-26
tags:
  - architecture
  - internals
  - design
---

# Architecture

This document explains how sum works internally. It's intended for contributors and users who want to understand the design decisions.

## Component Overview

```
┌─────────────────────────────────────────────────────────────┐
│                         sum                                  │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐  │
│  │   Service    │    │   Registry   │    │    Event     │  │
│  │  (singleton) │    │   (slush)    │    │  (capitan)   │  │
│  └──────┬───────┘    └──────────────┘    └──────────────┘  │
│         │                                                    │
│         ├────────────────┬───────────────┐                  │
│         ▼                ▼               ▼                  │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐        │
│  │    rocco     │ │     scio     │ │     fig      │        │
│  │  (HTTP)      │ │  (catalog)   │ │  (config)    │        │
│  └──────────────┘ └──────────────┘ └──────────────┘        │
│                          ▲                                   │
│                          │                                   │
│  ┌──────────────────────┴───────────────────────────────┐  │
│  │                    Data Helpers                        │  │
│  │   Database()     Store()     Bucket()                 │  │
│  │       │             │            │                     │  │
│  │       ▼             ▼            ▼                     │  │
│  │     grub        grub          grub                    │  │
│  └───────────────────────────────────────────────────────┘  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## Service Singleton

The `Service` is implemented as a process-wide singleton using `sync.Once`:

```go
var (
    instance *Service
    once     sync.Once
)

func New(cfg ServiceConfig) *Service {
    once.Do(func() {
        instance = &Service{
            engine:  rocco.NewEngine(cfg.Host, cfg.Port, nil),
            catalog: scio.New(),
            config:  cfg,
        }
    })
    return instance
}
```

**Why singleton?** An application has one HTTP server, one data catalog, one lifecycle. Multiple instances would create confusion about which is "the" service. The singleton pattern makes this explicit.

**Why `sync.Once`?** Safe concurrent initialization. The first caller to `New()` creates the instance; subsequent calls return it unchanged.

## Registry Delegation

Sum's registry functions delegate to [slush](https://github.com/zoobzio/slush):

```go
func Register[T any](k Key, impl T) *Handle[T] {
    return slush.Register[T](k, impl)
}

func Use[T any](ctx context.Context) (T, error) {
    return slush.Use[T](ctx)
}
```

**Why delegate?** Slush is the registry implementation; sum is the integration layer. This separation allows slush to be used independently and keeps sum focused on composition.

**The Key pattern:** `Start()` returns a `Key` that authorizes registration. `Freeze()` invalidates it. This prevents registration after startup, catching misconfiguration early.

## Event Wrapper

`Event[T]` wraps capitan's signal system with type safety:

```go
type Event[T any] struct {
    Signal capitan.Signal
    Key    capitan.GenericKey[T]
    level  capitan.Severity
}

func (e Event[T]) Emit(ctx context.Context, data T) {
    switch e.level {
    case capitan.SeverityInfo:
        capitan.Info(ctx, e.Signal, e.Key.Field(data))
    // ...
    }
}
```

**Why wrap?** Capitan signals are stringly-typed. The `Event[T]` wrapper uses generics to ensure emit and listen use the same payload type.

**Variant derivation:** `NewEvent` uses sentinel to derive a variant string from `T`, ensuring type-safe extraction on the listener side.

## Data Helper Flow

Each data helper follows the same pattern:

1. Create the underlying store (grub.Database, grub.Store, or grub.Bucket)
2. Pass it to the factory function to get a domain interface
3. Register the interface with slush
4. Register the store's atomic with scio

```go
func Database[C, M any](k Key, db *sqlx.DB, table, keyCol string,
    renderer astql.Renderer, factory func(*grub.Database[M]) C) error {

    gdb, err := grub.NewDatabase[M](db, table, keyCol, renderer)
    if err != nil {
        return err
    }

    impl := factory(gdb)
    Register[C](k, impl)

    s := svc()
    return s.catalog.RegisterDatabase("db://"+table, gdb.Atomic())
}
```

**Why the factory pattern?** The helper creates the raw store, but only you know your domain interface. The factory bridges the gap.

**Why register with scio?** The data catalog enables observability—knowing what data stores exist, their health, their metrics.

## Design Q&A

**Q: Why a singleton Service instead of explicit passing?**

Explicit passing is cleaner in theory but verbose in practice. The Service represents process-global state (the HTTP server, the data catalog). Making it a singleton acknowledges this reality and reduces ceremony.

**Q: Why delegate to slush instead of implementing the registry directly?**

Separation of concerns. Slush can evolve independently, be tested independently, and be used without sum. Sum stays focused on composition.

**Q: Why require a Key for registration?**

To prevent registration after startup. Without the Key pattern, any code anywhere could register services at any time, leading to race conditions and unpredictable behavior.

**Q: Why freeze the registry?**

Freezing prevents late registration, which would violate the assumption that services are available after startup. It's a sanity check that catches misconfiguration.

## Performance

**Registry lookup:** O(1) map access. Guards run sequentially on each lookup.

**Event dispatch:** O(n) where n is listener count. Listeners run synchronously by default.

**Startup cost:** Minimal. Registration is map insertion. The real cost is in the underlying stores (database connections, etc.).

## Next Steps

- [Service Registry Guide](../2.guides/3.service-registry.md) — Guards and advanced patterns
- [API Reference](../4.reference/1.api.md) — Complete function documentation
