---
title: Quickstart
description: Install sum and build your first application in minutes
author: zoobzio
published: 2026-01-26
updated: 2026-01-26
tags:
  - quickstart
  - getting-started
  - tutorial
---

# Quickstart

Get from zero to a running sum application.

## Installation

```bash
go get github.com/zoobzio/sum
```

Requires Go 1.24 or later.

## Basic Usage

A minimal sum application:

```go
package main

import (
    "context"
    "log"

    "github.com/zoobzio/sum"
)

// Define a service contract
type Greeter interface {
    Greet(name string) string
}

// Implement it
type greeterImpl struct{}

func (g *greeterImpl) Greet(name string) string {
    return "Hello, " + name
}

func main() {
    // Create the service singleton
    svc := sum.New(sum.ServiceConfig{Host: "localhost", Port: 8080})

    // Initialize the registry and get a key
    k := sum.Start()

    // Register your implementation
    sum.Register[Greeter](k, &greeterImpl{})

    // Freeze to prevent further registration
    sum.Freeze(k)

    // Use the service anywhere
    greeter := sum.MustUse[Greeter](context.Background())
    log.Println(greeter.Greet("World"))

    // Run with graceful shutdown
    if err := svc.Run(); err != nil {
        log.Fatal(err)
    }
}
```

## Service Registration

The registry uses Go generics for type-safe lookup:

```go
k := sum.Start()

// Register implementations against contract types
sum.Register[UserRepository](k, &pgUserRepo{db})
sum.Register[EmailSender](k, &smtpSender{config})

// Freeze when done registering
sum.Freeze(k)
```

See the [Service Registry Guide](../2.guides/3.service-registry.md) for guards and advanced patterns.

## Configuration

Load configuration and register it automatically:

```go
type AppConfig struct {
    DatabaseURL string `env:"DATABASE_URL"`
    APIKey      string `env:"API_KEY" secret:"true"`
}

// Load from environment, register as a service
err := sum.Config[AppConfig](ctx, k, secretProvider)

// Retrieve later
cfg := sum.MustUse[AppConfig](ctx)
```

## Events

Define typed events for application-wide signaling:

```go
// Define an event type
type UserCreated struct {
    ID    string
    Email string
}

// Create a typed event
var UserCreatedEvent = sum.NewInfoEvent[UserCreated](capitan.Signal("user.created"))

// Emit
UserCreatedEvent.Emit(ctx, UserCreated{ID: "123", Email: "user@example.com"})

// Listen
UserCreatedEvent.Listen(func(ctx context.Context, u UserCreated) {
    log.Printf("User created: %s", u.Email)
})
```

See the [Events Guide](../2.guides/4.events.md) for severity levels and one-time listeners.

## Data Stores

Wire databases to the registry and data catalog:

```go
type UserRepo interface {
    Find(ctx context.Context, id string) (*User, error)
}

err := sum.Database[UserRepo, User](
    k,
    db,              // *sqlx.DB
    "users",         // table name
    "id",            // key column
    renderer,        // astql.Renderer
    func(gdb *grub.Database[User]) UserRepo {
        return &userRepoImpl{gdb}
    },
)
```

See the [Data Stores Guide](../2.guides/5.data-stores.md) for KV stores and object buckets.

## Next Steps

- [Concepts](3.concepts.md) — Understand the mental models
- [Architecture](4.architecture.md) — Learn how sum works internally
- [API Reference](../4.reference/1.api.md) — Complete function documentation
